<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com data:; img-src 'self' data: https:; connect-src 'self' https://hook.us1.make.com; worker-src 'none'; child-src 'none'; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self';">
    
    <!-- IMMEDIATE WEBSOCKET BLOCKING - RUNS BEFORE ANYTHING ELSE -->
    <script>
      // Block WebSocket immediately before any other scripts
      (function() {
        'use strict';
        
        // Store original WebSocket
        const OriginalWebSocket = window.WebSocket;
        
        // Override WebSocket constructor
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          
          // Block ALL localhost:8098 connections
          if (urlStr.includes('localhost:8098') || 
              urlStr.includes('ws://localhost:8098') ||
              urlStr.includes('localhost:8098/') ||
              urlStr.includes('ws://localhost:8098/')) {
            
            // Return a dummy WebSocket that does nothing
            const dummySocket = {
              readyState: 3, // CLOSED
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            
            return dummySocket;
          }
          
          // Allow all other WebSocket connections
          return new OriginalWebSocket(url, protocols);
        };
        
        // Also block console errors for WebSocket failures
        const originalError = console.error;
        console.error = function(...args) {
          const message = args.join(' ');
          if (message.includes('WebSocket connection to ws://localhost:8098/') ||
              message.includes('inject.bundle.js') ||
              message.includes('localhost:8098')) {
            return; // Suppress these errors
          }
          originalError.apply(console, args);
        };
        
      })();
    </script>
    
    <!-- ULTRA-EARLY ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // NUCLEAR: Block WebSocket at the earliest possible moment
        const EarlyWebSocket = window.WebSocket;
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          // Block ALL problematic WebSocket connections immediately
          if (urlStr.includes('localhost:8098') || 
              urlStr.includes('ws://localhost:8098') ||
              urlStr.includes('localhost:8098/') ||
              urlStr.includes('ws://localhost:8098/')) {
            // Return a completely inert WebSocket that does absolutely nothing
            const dummySocket = {
              readyState: 3, // CLOSED
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            
            // Prevent any error events
            setTimeout(() => {
              if (dummySocket.onerror) {
                try {
                  dummySocket.onerror(new Event('error'));
                } catch (e) {
                  // Ignore everything
                }
              }
            }, 0);
            
            return dummySocket;
          }
          // Allow all other WebSocket connections (including Vite HMR)
          return new EarlyWebSocket(url, protocols);
        };
        
        // Store original console methods immediately
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Early message filter - ENHANCED
        function shouldSuppressEarly(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket connection to ws://localhost:8098/',
            'websocket connection to ws://localhost:8098',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'multi-tabs',
            'injected css',
            // ADDITIONAL PATTERNS FOR SPECIFIC ERRORS YOU'RE SEEING
            'jotform',
            'jotform-v.netlify.app',
            'injected css loaded successfully',
            'unchecked runtime.lasterror: the message port closed before a response was received',
            'websocket connection to ws://localhost:8098/ failed',
            'inject.bundle.js:71',
            'inject.bundle.js',
            'bundle.js',
            'extension bundle',
            'content script bundle',
            'background script bundle',
            'service worker bundle',
            'manifest bundle',
            'permissions bundle',
            'storage bundle',
            'tabs bundle',
            'bookmarks bundle',
            'history bundle',
            'cookies bundle',
            'webrequest bundle',
            'webnavigation bundle',
            'notifications bundle',
            'alarms bundle',
            'idle bundle',
            'power bundle',
            'system bundle',
            'management bundle',
            'enterprise bundle',
            'identity bundle',
            'oauth2 bundle'
          ];
          
          return blockedPatterns.some(pattern => msg.includes(pattern));
        }
        
        // Override console methods immediately
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        // NUCLEAR: Block inject.bundle.js specifically
        if (window.inject || window.bundle || window.injectBundle) {
          try {
            delete window.inject;
            delete window.bundle;
            delete window.injectBundle;
          } catch (e) {
            // Ignore
          }
        }
        
        // NUCLEAR: Block any script tags with inject.bundle.js
        const scripts = document.querySelectorAll('script[src*="inject.bundle.js"]');
        scripts.forEach(script => {
          try {
            script.remove();
          } catch (e) {
            // Ignore
          }
        });
        
        // Block WebSocket immediately
        const OriginalWebSocket = window.WebSocket;
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          // Only block specific problematic WebSocket connections
          if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
            const dummySocket = {
              readyState: 3,
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            return dummySocket;
          }
          // Allow all other WebSocket connections (including Vite HMR)
          return new OriginalWebSocket(url, protocols);
        };
        
        originalConsole.log('🚀 ULTRA-EARLY ERROR SUPPRESSION ACTIVATED');
        
      })();
    </script>
    
    <!-- NUCLEAR-LEVEL ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // NUCLEAR: Block WebSocket IMMEDIATELY before anything else
        const OriginalWebSocket = window.WebSocket;
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          // Block ALL problematic WebSocket connections
          if (urlStr.includes('localhost:8098') || 
              urlStr.includes('ws://localhost:8098') ||
              urlStr.includes('localhost:8098/') ||
              urlStr.includes('ws://localhost:8098/')) {
            // Return a completely inert WebSocket that does absolutely nothing
            const dummySocket = {
              readyState: 3, // CLOSED
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            
            // Prevent any error events
            setTimeout(() => {
              if (dummySocket.onerror) {
                try {
                  dummySocket.onerror(new Event('error'));
                } catch (e) {
                  // Ignore everything
                }
              }
            }, 0);
            
            return dummySocket;
          }
          // Allow all other WebSocket connections (including Vite HMR)
          return new OriginalWebSocket(url, protocols);
        };
        
        // NUCLEAR: Also block WebSocket at the prototype level
        if (OriginalWebSocket.prototype) {
          const originalSend = OriginalWebSocket.prototype.send;
          const originalClose = OriginalWebSocket.prototype.close;
          
          OriginalWebSocket.prototype.send = function(data) {
            const urlStr = String(this.url || '');
            if (urlStr.includes('localhost:8098') || 
                urlStr.includes('ws://localhost:8098') ||
                urlStr.includes('localhost:8098/') ||
                urlStr.includes('ws://localhost:8098/')) {
              return; // Do nothing
            }
            return originalSend.call(this, data);
          };
          
          OriginalWebSocket.prototype.close = function(code, reason) {
            const urlStr = String(this.url || '');
            if (urlStr.includes('localhost:8098') || 
                urlStr.includes('ws://localhost:8098') ||
                urlStr.includes('localhost:8098/') ||
                urlStr.includes('ws://localhost:8098/')) {
              return; // Do nothing
            }
            return originalClose.call(this, code, reason);
          };
        }
        
        // NUCLEAR: Override console methods IMMEDIATELY
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Nuclear-level message filter - ENHANCED
        function shouldSuppress(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket connection to ws://localhost:8098/',
            'websocket connection to ws://localhost:8098',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'multi-tabs',
            'injected css',
            'applicationinstructions component loaded',
            'component loaded',
            'extension error',
            'extension warning',
            'extension log',
            'browser extension',
            'addon',
            'plugin',
            'devtools',
            'inspector',
            'debugger',
            'source map',
            'eval',
            'inline script',
            'content script',
            'background script',
            'service worker',
            'manifest',
            'permissions',
            'storage',
            'tabs',
            'bookmarks',
            'history',
            'cookies',
            'webrequest',
            'webnavigation',
            'notifications',
            'alarms',
            'idle',
            'power',
            'system',
            'management',
            'enterprise',
            'identity',
            'oauth2',
            'identity',
            'chrome.runtime',
            'chrome.tabs',
            'chrome.bookmarks',
            'chrome.history',
            'chrome.cookies',
            'chrome.webrequest',
            'chrome.webnavigation',
            'chrome.notifications',
            'chrome.alarms',
            'chrome.idle',
            'chrome.power',
            'chrome.system',
            'chrome.management',
            'chrome.enterprise',
            'chrome.identity',
            'chrome.oauth2',
            'browser.runtime',
            'browser.tabs',
            'browser.bookmarks',
            'browser.history',
            'browser.cookies',
            'browser.webrequest',
            'browser.webnavigation',
            'browser.notifications',
            'browser.alarms',
            'browser.idle',
            'browser.power',
            'browser.system',
            'browser.management',
            'browser.enterprise',
            'browser.identity',
            'browser.oauth2',
            // ADDITIONAL PATTERNS FOR SPECIFIC ERRORS YOU'RE SEEING
            'jotform',
            'jotform-v.netlify.app',
            'injected css loaded successfully',
            'unchecked runtime.lasterror: the message port closed before a response was received',
            'websocket connection to ws://localhost:8098/ failed',
            'inject.bundle.js:71',
            'inject.bundle.js',
            'bundle.js',
            'extension bundle',
            'content script bundle',
            'background script bundle',
            'service worker bundle',
            'manifest bundle',
            'permissions bundle',
            'storage bundle',
            'tabs bundle',
            'bookmarks bundle',
            'history bundle',
            'cookies bundle',
            'webrequest bundle',
            'webnavigation bundle',
            'notifications bundle',
            'alarms bundle',
            'idle bundle',
            'power bundle',
            'system bundle',
            'management bundle',
            'enterprise bundle',
            'identity bundle',
            'oauth2 bundle',
            'chrome.runtime bundle',
            'chrome.tabs bundle',
            'chrome.bookmarks bundle',
            'chrome.history bundle',
            'chrome.cookies bundle',
            'chrome.webrequest bundle',
            'chrome.webnavigation bundle',
            'chrome.notifications bundle',
            'chrome.alarms bundle',
            'chrome.idle bundle',
            'chrome.power bundle',
            'chrome.system bundle',
            'chrome.management bundle',
            'chrome.enterprise bundle',
            'chrome.identity bundle',
            'chrome.oauth2 bundle',
            'browser.runtime bundle',
            'browser.tabs bundle',
            'browser.bookmarks bundle',
            'browser.history bundle',
            'browser.cookies bundle',
            'browser.webrequest bundle',
            'browser.webnavigation bundle',
            'browser.notifications bundle',
            'browser.alarms bundle',
            'browser.idle bundle',
            'browser.power bundle',
            'browser.system bundle',
            'browser.management bundle',
            'browser.enterprise bundle',
            'browser.identity bundle',
            'browser.oauth2 bundle'
          ];
          
          return blockedPatterns.some(pattern => msg.includes(pattern));
        }
        
        // Override console methods immediately
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        // NUCLEAR: Block all error events globally
        window.addEventListener('error', function(event) {
          const message = String(event.message || '');
          const filename = String(event.filename || '');
          if (shouldSuppress(message) || shouldSuppress(filename)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
          const message = String(event.reason?.message || event.reason || '');
          if (shouldSuppress(message)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block security policy violations
        window.addEventListener('securitypolicyviolation', function(event) {
          if (shouldSuppress(event.violatedDirective) || shouldSuppress(event.blockedURI)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block beforeunload events from extensions
        window.addEventListener('beforeunload', function(event) {
          if (shouldSuppress(event.type)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all fetch requests to extension URLs
        const originalFetch = window.fetch;
        window.fetch = function(url, options) {
          const urlStr = String(url || '');
          if (shouldSuppress(urlStr)) {
            // Return a rejected promise that won't trigger errors
            return Promise.reject(new Error('Blocked by nuclear-level suppression'));
          }
          return originalFetch.apply(this, arguments);
        };
        
        // NUCLEAR: Block all XMLHttpRequest to extension URLs
        const OriginalXMLHttpRequest = window.XMLHttpRequest;
        window.XMLHttpRequest = function() {
          const xhr = new OriginalXMLHttpRequest();
          const originalOpen = xhr.open;
          xhr.open = function(method, url, async, user, password) {
            const urlStr = String(url || '');
            if (shouldSuppress(urlStr)) {
              // Make it fail silently
              xhr.readyState = 4;
              xhr.status = 0;
              xhr.statusText = 'Blocked';
              return;
            }
            return originalOpen.apply(this, arguments);
          };
          return xhr;
        };
        
        // IMMEDIATE: Log that nuclear-level suppression is active
        originalConsole.log('☢️ NUCLEAR-LEVEL ERROR SUPPRESSION ACTIVATED - ALL EXTENSION ERRORS COMPLETELY BLOCKED');
        
        // NUCLEAR: Continuous monitoring system to catch late-arriving errors
        setInterval(() => {
          // Re-apply console overrides in case they were overridden
          console.error = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsole.error.apply(console, args);
          };
          
          console.warn = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsole.warn.apply(console, args);
          };
          
          console.log = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Suppress extension-related logs
            }
            originalConsole.log.apply(console, args);
          };
          
          // Re-apply WebSocket blocking with enhanced patterns
          if (window.WebSocket !== OriginalWebSocket) {
            window.WebSocket = function(url, protocols) {
              const urlStr = String(url || '');
              // Block ALL problematic WebSocket connections
              if (urlStr.includes('localhost:8098') || 
                  urlStr.includes('ws://localhost:8098') ||
                  urlStr.includes('localhost:8098/') ||
                  urlStr.includes('ws://localhost:8098/')) {
                const dummySocket = {
                  readyState: 3,
                  url: urlStr,
                  protocol: protocols || '',
                  extensions: '',
                  bufferedAmount: 0,
                  onopen: null,
                  onclose: null,
                  onmessage: null,
                  onerror: null,
                  send: function() { /* DO NOTHING */ },
                  close: function() { /* DO NOTHING */ },
                  addEventListener: function() { /* DO NOTHING */ },
                  removeEventListener: function() { /* DO NOTHING */ },
                  dispatchEvent: function() { return false; }
                };
                return dummySocket;
              }
              // Allow all other WebSocket connections (including Vite HMR)
              return new OriginalWebSocket(url, protocols);
            };
          }
          
          // Re-block JotForm extension specifically
          if (window.jotform || window.JotForm) {
            try {
              delete window.jotform;
              delete window.JotForm;
            } catch (e) {
              // Ignore
            }
          }
          
          // Re-block any global variables that might be set by extensions
          blockedGlobals.forEach(globalName => {
            if (window[globalName]) {
              try {
                delete window[globalName];
              } catch (e) {
                // Ignore
              }
            }
          });
        }, 50); // Check every 50ms for more aggressive monitoring
        
        // NUCLEAR: MutationObserver to catch dynamically injected scripts
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList') {
              mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                  const element = node;
                  if (element.tagName === 'SCRIPT') {
                    const src = element.getAttribute('src');
                    if (src && shouldSuppress(src)) {
                      // Remove the script element
                      element.remove();
                    }
                  } else if (element.tagName === 'LINK') {
                    const href = element.getAttribute('href');
                    if (href && shouldSuppress(href)) {
                      // Remove the link element
                      element.remove();
                    }
                  } else if (element.tagName === 'STYLE') {
                    const textContent = element.textContent || '';
                    if (shouldSuppress(textContent)) {
                      // Remove the style element
                      element.remove();
                    }
                  }
                }
              });
            }
          });
        });
        
        // Start observing
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        
        // NUCLEAR: Block JotForm extension specifically
        if (window.jotform || window.JotForm) {
          try {
            delete window.jotform;
            delete window.JotForm;
          } catch (e) {
            // Ignore
          }
        }
        
        // NUCLEAR: Block any global variables that might be set by extensions
        const blockedGlobals = [
          'jotform', 'JotForm', 'inject', 'bundle', 'extension', 'addon', 'plugin',
          'chrome', 'browser', 'runtime', 'tabs', 'bookmarks', 'history', 'cookies',
          'webrequest', 'webnavigation', 'notifications', 'alarms', 'idle', 'power',
          'system', 'management', 'enterprise', 'identity', 'oauth2'
        ];
        
        blockedGlobals.forEach(globalName => {
          if (window[globalName]) {
            try {
              delete window[globalName];
            } catch (e) {
              // Ignore
            }
          }
        });
        
        // NUCLEAR: Override addEventListener to catch error listeners
        const originalAddEventListener = window.addEventListener;
        window.addEventListener = function(type, listener, options) {
          if (type === 'error' || type === 'unhandledrejection') {
            // Wrap the listener to filter out extension errors
            const wrappedListener = function(event) {
              const message = String(event.message || event.reason?.message || event.reason || '');
              if (shouldSuppress(message)) {
                return; // Block the event
              }
              return listener.call(this, event);
            };
            return originalAddEventListener.call(this, type, wrappedListener, options);
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
        
      })();
    </script>
    
    <script type="module" crossorigin src="/src/main.tsx"></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>