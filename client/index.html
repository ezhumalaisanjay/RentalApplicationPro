<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com data:; img-src 'self' data: https:; connect-src 'self' https://hook.us1.make.com; worker-src 'none'; child-src 'none'; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self';">
    
    <!-- ULTRA-EARLY ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // Store original console methods immediately
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Early message filter
        function shouldSuppressEarly(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket not connected',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'multi-tabs',
            'injected css'
          ];
          
          return blockedPatterns.some(pattern => msg.includes(pattern));
        }
        
        // Override console methods immediately
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        originalConsole.log('🚀 ULTRA-EARLY ERROR SUPPRESSION ACTIVATED');
        
      })();
    </script>
    
    <!-- NUCLEAR-LEVEL ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // NUCLEAR: Override console methods IMMEDIATELY
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Nuclear-level message filter - ENHANCED
        function shouldSuppress(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket not connected',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'multi-tabs',
            'injected css',
            'applicationinstructions component loaded',
            'component loaded',
            'extension error',
            'extension warning',
            'extension log',
            'browser extension',
            'addon',
            'plugin',
            'devtools',
            'inspector',
            'debugger',
            'source map',
            'eval',
            'inline script',
            'content script',
            'background script',
            'service worker',
            'manifest',
            'permissions',
            'storage',
            'tabs',
            'bookmarks',
            'history',
            'cookies',
            'webrequest',
            'webnavigation',
            'notifications',
            'alarms',
            'idle',
            'power',
            'system',
            'management',
            'enterprise',
            'identity',
            'oauth2',
            'identity',
            'chrome.runtime',
            'chrome.tabs',
            'chrome.bookmarks',
            'chrome.history',
            'chrome.cookies',
            'chrome.webrequest',
            'chrome.webnavigation',
            'chrome.notifications',
            'chrome.alarms',
            'chrome.idle',
            'chrome.power',
            'chrome.system',
            'chrome.management',
            'chrome.enterprise',
            'chrome.identity',
            'chrome.oauth2',
            'browser.runtime',
            'browser.tabs',
            'browser.bookmarks',
            'browser.history',
            'browser.cookies',
            'browser.webrequest',
            'browser.webnavigation',
            'browser.notifications',
            'browser.alarms',
            'browser.idle',
            'browser.power',
            'browser.system',
            'browser.management',
            'browser.enterprise',
            'browser.identity',
            'browser.oauth2'
          ];
          
          return blockedPatterns.some(pattern => msg.includes(pattern));
        }
        
        // Override console methods immediately
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        // NUCLEAR: Block all error events globally
        window.addEventListener('error', function(event) {
          const message = String(event.message || '');
          const filename = String(event.filename || '');
          if (shouldSuppress(message) || shouldSuppress(filename)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
          const message = String(event.reason?.message || event.reason || '');
          if (shouldSuppress(message)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block security policy violations
        window.addEventListener('securitypolicyviolation', function(event) {
          if (shouldSuppress(event.violatedDirective) || shouldSuppress(event.blockedURI)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block beforeunload events from extensions
        window.addEventListener('beforeunload', function(event) {
          if (shouldSuppress(event.type)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all fetch requests to extension URLs
        const originalFetch = window.fetch;
        window.fetch = function(url, options) {
          const urlStr = String(url || '');
          if (shouldSuppress(urlStr)) {
            // Return a rejected promise that won't trigger errors
            return Promise.reject(new Error('Blocked by nuclear-level suppression'));
          }
          return originalFetch.apply(this, arguments);
        };
        
        // NUCLEAR: Block all XMLHttpRequest to extension URLs
        const OriginalXMLHttpRequest = window.XMLHttpRequest;
        window.XMLHttpRequest = function() {
          const xhr = new OriginalXMLHttpRequest();
          const originalOpen = xhr.open;
          xhr.open = function(method, url, async, user, password) {
            const urlStr = String(url || '');
            if (shouldSuppress(urlStr)) {
              // Make it fail silently
              xhr.readyState = 4;
              xhr.status = 0;
              xhr.statusText = 'Blocked';
              return;
            }
            return originalOpen.apply(this, arguments);
          };
          return xhr;
        };
        
        // IMMEDIATE: Log that nuclear-level suppression is active
        originalConsole.log('☢️ NUCLEAR-LEVEL ERROR SUPPRESSION ACTIVATED - ALL EXTENSION ERRORS COMPLETELY BLOCKED');
        
        // NUCLEAR: Continuous monitoring system to catch late-arriving errors
        setInterval(() => {
          // Re-apply console overrides in case they were overridden
          console.error = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsole.error.apply(console, args);
          };
          
          console.warn = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsole.warn.apply(console, args);
          };
          
          console.log = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Suppress extension-related logs
            }
            originalConsole.log.apply(console, args);
          };
        }, 100); // Check every 100ms
        
        // NUCLEAR: MutationObserver to catch dynamically injected scripts
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList') {
              mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                  const element = node;
                  if (element.tagName === 'SCRIPT') {
                    const src = element.getAttribute('src');
                    if (src && shouldSuppress(src)) {
                      // Remove the script element
                      element.remove();
                    }
                  }
                }
              });
            }
          });
        });
        
        // Start observing
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        
        // NUCLEAR: Override addEventListener to catch error listeners
        const originalAddEventListener = window.addEventListener;
        window.addEventListener = function(type, listener, options) {
          if (type === 'error' || type === 'unhandledrejection') {
            // Wrap the listener to filter out extension errors
            const wrappedListener = function(event) {
              const message = String(event.message || event.reason?.message || event.reason || '');
              if (shouldSuppress(message)) {
                return; // Block the event
              }
              return listener.call(this, event);
            };
            return originalAddEventListener.call(this, type, wrappedListener, options);
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
        
      })();
    </script>
    
    <script type="module" crossorigin src="/src/main.tsx"></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>