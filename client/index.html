<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com data:; img-src 'self' data: https:; connect-src 'self' https://hook.us1.make.com; worker-src 'none'; child-src 'none'; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self';">
    
    <!-- NUCLEAR-LEVEL ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // NUCLEAR: Block WebSocket IMMEDIATELY before anything else
        const OriginalWebSocket = window.WebSocket;
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
            // Return a completely inert WebSocket that does absolutely nothing
            const dummySocket = {
              readyState: 3, // CLOSED
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            
            // Prevent any error events
            setTimeout(() => {
              if (dummySocket.onerror) {
                try {
                  dummySocket.onerror(new Event('error'));
                } catch (e) {
                  // Ignore everything
                }
              }
            }, 0);
            
            return dummySocket;
          }
          return new OriginalWebSocket(url, protocols);
        };
        
        // NUCLEAR: Override console methods IMMEDIATELY
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Nuclear-level message filter
        function shouldSuppress(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket connection to ws://localhost:8098/',
            'websocket connection to ws://localhost:8098',
            'websocket not connected',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'websocket',
            'ws://localhost',
            'websocket connection failed',
            'websocket error',
            'multi-tabs',
            'injected css'
          ];
          
          return blockedPatterns.some(pattern => msg.includes(pattern));
        }
        
        // Override console.error with nuclear-level filtering
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        // Override console.warn with nuclear-level filtering
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        // Override console.log to filter extension messages
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        // NUCLEAR: Block all error events immediately with capture
        window.addEventListener('error', function(event) {
          const message = String(event.message || '');
          const filename = String(event.filename || '');
          if (shouldSuppress(message) || shouldSuppress(filename)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all unhandled promise rejections immediately with capture
        window.addEventListener('unhandledrejection', function(event) {
          const message = String(event.reason?.message || event.reason || '');
          if (shouldSuppress(message)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block security policy violations
        window.addEventListener('securitypolicyviolation', function(event) {
          if (shouldSuppress(event.violatedDirective) || shouldSuppress(event.blockedURI)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block beforeunload events from extensions
        window.addEventListener('beforeunload', function(event) {
          if (shouldSuppress(event.type)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all console methods from extensions
        const originalConsoleMethods = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Override again to catch any late attempts
        setTimeout(() => {
          console.error = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsoleMethods.error.apply(console, args);
          };
          
          console.warn = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsoleMethods.warn.apply(console, args);
          };
          
          console.log = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Suppress extension-related logs
            }
            originalConsoleMethods.log.apply(console, args);
          };
        }, 0);
        
        // IMMEDIATE: Log that nuclear-level suppression is active
        originalConsole.log('☢️ NUCLEAR-LEVEL ERROR SUPPRESSION ACTIVATED - ALL EXTENSION ERRORS COMPLETELY BLOCKED');
        
      })();
    </script>
    
    <script type="module" crossorigin src="/src/main.tsx"></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>