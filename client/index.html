<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com data:; img-src 'self' data: https:; connect-src 'self' https://hook.us1.make.com; worker-src 'none'; child-src 'none'; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self';">
    
    <!-- ULTRA-EARLY ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // Store original console methods immediately
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Early message filter
        function shouldSuppressEarly(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket connection to ws://localhost:8098/',
            'websocket connection to ws://localhost:8098',
            'websocket not connected',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'websocket',
            'ws://localhost',
            'websocket connection failed',
            'websocket error',
            'multi-tabs',
            'injected css'
          ];
          
          return blockedPatterns.some(pattern => msg.includes(pattern));
        }
        
        // Override console methods immediately
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        // Block WebSocket immediately
        const OriginalWebSocket = window.WebSocket;
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
            const dummySocket = {
              readyState: 3,
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            return dummySocket;
          }
          return new OriginalWebSocket(url, protocols);
        };
        
        originalConsole.log('🚀 ULTRA-EARLY ERROR SUPPRESSION ACTIVATED');
        
      })();
    </script>
    
    <!-- NUCLEAR-LEVEL ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // NUCLEAR: Block WebSocket IMMEDIATELY before anything else
        const OriginalWebSocket = window.WebSocket;
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
            // Return a completely inert WebSocket that does absolutely nothing
            const dummySocket = {
              readyState: 3, // CLOSED
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            
            // Prevent any error events
            setTimeout(() => {
              if (dummySocket.onerror) {
                try {
                  dummySocket.onerror(new Event('error'));
                } catch (e) {
                  // Ignore everything
                }
              }
            }, 0);
            
            return dummySocket;
          }
          return new OriginalWebSocket(url, protocols);
        };
        
        // NUCLEAR: Override console methods IMMEDIATELY
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Nuclear-level message filter - ENHANCED
        function shouldSuppress(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket connection to ws://localhost:8098/',
            'websocket connection to ws://localhost:8098',
            'websocket not connected',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'websocket',
            'ws://localhost',
            'websocket connection failed',
            'websocket error',
            'multi-tabs',
            'injected css',
            'applicationinstructions component loaded',
            'component loaded',
            'extension error',
            'extension warning',
            'extension log',
            'browser extension',
            'addon',
            'plugin',
            'devtools',
            'inspector',
            'debugger',
            'source map',
            'eval',
            'inline script',
            'content script',
            'background script',
            'service worker',
            'manifest',
            'permissions',
            'storage',
            'tabs',
            'bookmarks',
            'history',
            'cookies',
            'webrequest',
            'webnavigation',
            'notifications',
            'alarms',
            'idle',
            'power',
            'system',
            'management',
            'enterprise',
            'identity',
            'oauth2',
            'identity',
            'chrome.runtime',
            'chrome.tabs',
            'chrome.bookmarks',
            'chrome.history',
            'chrome.cookies',
            'chrome.webrequest',
            'chrome.webnavigation',
            'chrome.notifications',
            'chrome.alarms',
            'chrome.idle',
            'chrome.power',
            'chrome.system',
            'chrome.management',
            'chrome.enterprise',
            'chrome.identity',
            'chrome.oauth2',
            'browser.runtime',
            'browser.tabs',
            'browser.bookmarks',
            'browser.history',
            'browser.cookies',
            'browser.webrequest',
            'browser.webnavigation',
            'browser.notifications',
            'browser.alarms',
            'browser.idle',
            'browser.power',
            'browser.system',
            'browser.management',
            'browser.enterprise',
            'browser.identity',
            'browser.oauth2',
            // Specific patterns from the current errors
            'understand this error',
            'inject.bundle.js:71',
            'inject.bundle.js:216',
            'multi-tabs.js:3565',
            'jotform-v.netlify.app',
            'anonymous',
            'e @',
            '@ inject.bundle.js',
            '@ multi-tabs.js',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'ws://localhost:8098',
            'websocket connection to',
            'websocket connection failed',
            'websocket error',
            'message port closed',
            'runtime.lasterror',
            'unchecked runtime.lasterror',
            'injected css loaded successfully',
            'multi-tabs',
            'hook.js',
            'inject.bundle',
            'multi-tabs.js',
            'hook.js',
            'injected css',
            'extension error',
            'extension warning',
            'extension log',
            'browser extension',
            'addon',
            'plugin',
            'devtools',
            'inspector',
            'debugger',
            'source map',
            'eval',
            'inline script',
            'content script',
            'background script',
            'service worker',
            'manifest',
            'permissions',
            'storage',
            'tabs',
            'bookmarks',
            'history',
            'cookies',
            'webrequest',
            'webnavigation',
            'notifications',
            'alarms',
            'idle',
            'power',
            'system',
            'management',
            'enterprise',
            'identity',
            'oauth2',
            'chrome.runtime',
            'chrome.tabs',
            'chrome.bookmarks',
            'chrome.history',
            'chrome.cookies',
            'chrome.webrequest',
            'chrome.webnavigation',
            'chrome.notifications',
            'chrome.alarms',
            'chrome.idle',
            'chrome.power',
            'chrome.system',
            'chrome.management',
            'chrome.enterprise',
            'chrome.identity',
            'chrome.oauth2',
            'browser.runtime',
            'browser.tabs',
            'browser.bookmarks',
            'browser.history',
            'browser.cookies',
            'browser.webrequest',
            'browser.webnavigation',
            'browser.notifications',
            'browser.alarms',
            'browser.idle',
            'browser.power',
            'browser.system',
            'browser.management',
            'browser.enterprise',
            'browser.identity',
            'browser.oauth2'
          ];
          
          return blockedPatterns.some(pattern => msg.includes(pattern));
        }
        
        // Override console.error with nuclear-level filtering
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        // Override console.warn with nuclear-level filtering
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        // Override console.log to filter extension messages
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        // NUCLEAR: Block all error events globally
        window.addEventListener('error', function(event) {
          const message = String(event.message || '');
          const filename = String(event.filename || '');
          if (shouldSuppress(message) || shouldSuppress(filename)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
          const message = String(event.reason?.message || event.reason || '');
          if (shouldSuppress(message)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block security policy violations
        window.addEventListener('securitypolicyviolation', function(event) {
          if (shouldSuppress(event.violatedDirective) || shouldSuppress(event.blockedURI)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block beforeunload events from extensions
        window.addEventListener('beforeunload', function(event) {
          if (shouldSuppress(event.type)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all fetch requests to extension URLs
        const originalFetch = window.fetch;
        window.fetch = function(url, options) {
          const urlStr = String(url || '');
          if (shouldSuppress(urlStr)) {
            // Return a rejected promise that won't trigger errors
            return Promise.reject(new Error('Blocked by nuclear-level suppression'));
          }
          return originalFetch.apply(this, arguments);
        };
        
        // NUCLEAR: Block all XMLHttpRequest to extension URLs
        const OriginalXMLHttpRequest = window.XMLHttpRequest;
        window.XMLHttpRequest = function() {
          const xhr = new OriginalXMLHttpRequest();
          const originalOpen = xhr.open;
          xhr.open = function(method, url, async, user, password) {
            const urlStr = String(url || '');
            if (shouldSuppress(urlStr)) {
              // Make it fail silently
              xhr.readyState = 4;
              xhr.status = 0;
              xhr.statusText = 'Blocked';
              return;
            }
            return originalOpen.apply(this, arguments);
          };
          return xhr;
        };
        
        // IMMEDIATE: Log that nuclear-level suppression is active
        originalConsole.log('☢️ NUCLEAR-LEVEL ERROR SUPPRESSION ACTIVATED - ALL EXTENSION ERRORS COMPLETELY BLOCKED');
        
        // NUCLEAR: Continuous monitoring system to catch late-arriving errors
        setInterval(() => {
          // Re-apply console overrides in case they were overridden
          console.error = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsole.error.apply(console, args);
          };
          
          console.warn = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsole.warn.apply(console, args);
          };
          
          console.log = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Suppress extension-related logs
            }
            originalConsole.log.apply(console, args);
          };
          
          // Re-apply WebSocket blocking
          if (window.WebSocket !== OriginalWebSocket) {
            window.WebSocket = function(url, protocols) {
              const urlStr = String(url || '');
              if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
                const dummySocket = {
                  readyState: 3,
                  url: urlStr,
                  protocol: protocols || '',
                  extensions: '',
                  bufferedAmount: 0,
                  onopen: null,
                  onclose: null,
                  onmessage: null,
                  onerror: null,
                  send: function() { /* DO NOTHING */ },
                  close: function() { /* DO NOTHING */ },
                  addEventListener: function() { /* DO NOTHING */ },
                  removeEventListener: function() { /* DO NOTHING */ },
                  dispatchEvent: function() { return false; }
                };
                return dummySocket;
              }
              return new OriginalWebSocket(url, protocols);
            };
          }
        }, 100); // Check every 100ms
        
        // NUCLEAR: MutationObserver to catch dynamically injected scripts
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList') {
              mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                  const element = node;
                  // Block any script tags that might be extension-related
                  if (element.tagName === 'SCRIPT') {
                    const src = element.getAttribute('src') || '';
                    if (shouldSuppress(src)) {
                      element.remove();
                      return;
                    }
                  }
                  // Block any iframes that might be extension-related
                  if (element.tagName === 'IFRAME') {
                    const src = element.getAttribute('src') || '';
                    if (shouldSuppress(src)) {
                      element.remove();
                      return;
                    }
                  }
                }
              });
            }
          });
        });
        
        // Start observing
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        
        // NUCLEAR: Block all global error handlers that extensions might add
        const originalAddEventListener = window.addEventListener;
        window.addEventListener = function(type, listener, options) {
          if (type === 'error' || type === 'unhandledrejection') {
            // Wrap the listener to filter out extension errors
            const wrappedListener = function(event) {
              const message = String(event.message || event.reason?.message || event.reason || '');
              if (shouldSuppress(message)) {
                return; // Block the event
              }
              return listener.call(this, event);
            };
            return originalAddEventListener.call(this, type, wrappedListener, options);
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
        
        // NUCLEAR: Block all error propagation at the DOM level
        const originalDispatchEvent = EventTarget.prototype.dispatchEvent;
        EventTarget.prototype.dispatchEvent = function(event) {
          if (event.type === 'error' || event.type === 'unhandledrejection') {
            const message = String(event.message || event.reason?.message || event.reason || '');
            if (shouldSuppress(message)) {
              event.preventDefault();
              event.stopImmediatePropagation();
              return false; // Block the event entirely
            }
          }
          return originalDispatchEvent.call(this, event);
        };
        
        // NUCLEAR: Block all console methods at the prototype level
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        const originalConsoleLog = console.log;
        
        Object.defineProperty(console, 'error', {
          value: function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            return originalConsoleError.apply(console, args);
          },
          writable: false,
          configurable: false
        });
        
        Object.defineProperty(console, 'warn', {
          value: function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            return originalConsoleWarn.apply(console, args);
          },
          writable: false,
          configurable: false
        });
        
        Object.defineProperty(console, 'log', {
          value: function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Suppress extension-related logs
            }
            return originalConsoleLog.apply(console, args);
          },
          writable: false,
          configurable: false
        });
        
        // NUCLEAR: Block all error constructors
        const originalError = window.Error;
        window.Error = function(message, ...args) {
          if (shouldSuppress(String(message || ''))) {
            // Return a silent error that does nothing
            const silentError = new originalError('Blocked by nuclear suppression');
            silentError.stack = '';
            silentError.message = '';
            return silentError;
          }
          return new originalError(message, ...args);
        };
        
        // NUCLEAR: Block all Promise rejections at the constructor level
        const originalPromise = window.Promise;
        window.Promise = function(executor) {
          return new originalPromise(function(resolve, reject) {
            const wrappedReject = function(reason) {
              if (shouldSuppress(String(reason || ''))) {
                // Silently ignore the rejection
                return;
              }
              return reject(reason);
            };
            return executor(resolve, wrappedReject);
          });
        };
        
        // NUCLEAR: Block all setTimeout/setInterval that might be used by extensions
        const originalSetTimeout = window.setTimeout;
        const originalSetInterval = window.setInterval;
        
        window.setTimeout = function(func, delay, ...args) {
          if (typeof func === 'string' && shouldSuppress(func)) {
            return 0; // Return invalid timeout ID
          }
          if (typeof func === 'function') {
            const wrappedFunc = function(...funcArgs) {
              try {
                return func.apply(this, funcArgs);
              } catch (error) {
                if (shouldSuppress(String(error || ''))) {
                  return; // Silently ignore
                }
                throw error;
              }
            };
            return originalSetTimeout(wrappedFunc, delay, ...args);
          }
          return originalSetTimeout(func, delay, ...args);
        };
        
        window.setInterval = function(func, delay, ...args) {
          if (typeof func === 'string' && shouldSuppress(func)) {
            return 0; // Return invalid interval ID
          }
          if (typeof func === 'function') {
            const wrappedFunc = function(...funcArgs) {
              try {
                return func.apply(this, funcArgs);
              } catch (error) {
                if (shouldSuppress(String(error || ''))) {
                  return; // Silently ignore
                }
                throw error;
              }
            };
            return originalSetInterval(wrappedFunc, delay, ...args);
          }
          return originalSetInterval(func, delay, ...args);
        };
        
        // NUCLEAR: Block all eval and Function constructors
        const originalEval = window.eval;
        window.eval = function(code) {
          if (shouldSuppress(String(code || ''))) {
            return undefined; // Return undefined instead of executing
          }
          return originalEval(code);
        };
        
        const originalFunction = window.Function;
        window.Function = function(...args) {
          const code = args.join('');
          if (shouldSuppress(code)) {
            return function() { return undefined; }; // Return empty function
          }
          return originalFunction.apply(this, args);
        };
        
        // NUCLEAR: Block all error stack traces
        const originalErrorStack = Error.prototype.stack;
        Object.defineProperty(Error.prototype, 'stack', {
          get: function() {
            const stack = originalErrorStack;
            if (shouldSuppress(stack)) {
              return ''; // Return empty stack trace
            }
            return stack;
          },
          set: function(value) {
            if (shouldSuppress(String(value || ''))) {
              return; // Don't set the stack trace
            }
            originalErrorStack = value;
          }
        });
        
        // NUCLEAR: Block all console methods at the deepest level possible
        const consoleProxy = new Proxy(console, {
          get: function(target, prop) {
            if (prop === 'error' || prop === 'warn' || prop === 'log') {
              return function(...args) {
                const message = args.join(' ');
                if (shouldSuppress(message)) {
                  return; // Completely suppress
                }
                return target[prop].apply(target, args);
              };
            }
            return target[prop];
          }
        });
        
        // Replace the global console with our proxy
        Object.defineProperty(window, 'console', {
          value: consoleProxy,
          writable: false,
          configurable: false
        });
        
        // NUCLEAR: Block all error events at the window level
        const originalWindowError = window.onerror;
        window.onerror = function(message, source, lineno, colno, error) {
          if (shouldSuppress(String(message || '')) || shouldSuppress(String(source || ''))) {
            return true; // Prevent the error from being logged
          }
          if (originalWindowError) {
            return originalWindowError.call(this, message, source, lineno, colno, error);
          }
          return false;
        };
        
        // NUCLEAR: Block all unhandledrejection events at the window level
        const originalWindowUnhandledRejection = window.onunhandledrejection;
        window.onunhandledrejection = function(event) {
          if (shouldSuppress(String(event.reason || ''))) {
            event.preventDefault();
            return true; // Prevent the rejection from being logged
          }
          if (originalWindowUnhandledRejection) {
            return originalWindowUnhandledRejection.call(this, event);
          }
          return false;
        };
        
      })();
    </script>
    
    <script type="module" crossorigin src="/src/main.tsx"></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>