<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com data:; img-src 'self' data: https:; connect-src 'self' https://hook.us1.make.com; worker-src 'none'; child-src 'none'; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self';">
    
    <!-- NUCLEAR-LEVEL ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // NUCLEAR: Block WebSocket IMMEDIATELY before anything else
        const OriginalWebSocket = window.WebSocket;
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
            // Return a completely inert WebSocket that does absolutely nothing
            const dummySocket = {
              readyState: 3, // CLOSED
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            
            // Prevent any error events
            setTimeout(() => {
              if (dummySocket.onerror) {
                try {
                  dummySocket.onerror(new Event('error'));
                } catch (e) {
                  // Ignore everything
                }
              }
            }, 0);
            
            return dummySocket;
          }
          return new OriginalWebSocket(url, protocols);
        };
        
        // NUCLEAR: Override console methods IMMEDIATELY
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Nuclear-level message filter - ENHANCED
        function shouldSuppress(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket connection to ws://localhost:8098/',
            'websocket connection to ws://localhost:8098',
            'websocket not connected',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'websocket',
            'ws://localhost',
            'websocket connection failed',
            'websocket error',
            'multi-tabs',
            'injected css',
            'applicationinstructions component loaded',
            'component loaded',
            'extension error',
            'extension warning',
            'extension log',
            'browser extension',
            'addon',
            'plugin',
            'devtools',
            'inspector',
            'debugger',
            'source map',
            'eval',
            'inline script',
            'content script',
            'background script',
            'service worker',
            'manifest',
            'permissions',
            'storage',
            'tabs',
            'bookmarks',
            'history',
            'cookies',
            'webrequest',
            'webnavigation',
            'notifications',
            'alarms',
            'idle',
            'power',
            'system',
            'management',
            'enterprise',
            'identity',
            'oauth2',
            'identity',
            'chrome.runtime',
            'chrome.tabs',
            'chrome.bookmarks',
            'chrome.history',
            'chrome.cookies',
            'chrome.webrequest',
            'chrome.webnavigation',
            'chrome.notifications',
            'chrome.alarms',
            'chrome.idle',
            'chrome.power',
            'chrome.system',
            'chrome.management',
            'chrome.enterprise',
            'chrome.identity',
            'chrome.oauth2',
            'browser.runtime',
            'browser.tabs',
            'browser.bookmarks',
            'browser.history',
            'browser.cookies',
            'browser.webrequest',
            'browser.webnavigation',
            'browser.notifications',
            'browser.alarms',
            'browser.idle',
            'browser.power',
            'browser.system',
            'browser.management',
            'browser.enterprise',
            'browser.identity',
            'browser.oauth2'
          ];
          
          return blockedPatterns.some(pattern => msg.includes(pattern));
        }
        
        // Override console.error with nuclear-level filtering
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        // Override console.warn with nuclear-level filtering
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        // Override console.log to filter extension messages
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        // NUCLEAR: Block all error events globally
        window.addEventListener('error', function(event) {
          const message = String(event.message || '');
          const filename = String(event.filename || '');
          if (shouldSuppress(message) || shouldSuppress(filename)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
          const message = String(event.reason?.message || event.reason || '');
          if (shouldSuppress(message)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block security policy violations
        window.addEventListener('securitypolicyviolation', function(event) {
          if (shouldSuppress(event.violatedDirective) || shouldSuppress(event.blockedURI)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block beforeunload events from extensions
        window.addEventListener('beforeunload', function(event) {
          if (shouldSuppress(event.type)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all fetch requests to extension URLs
        const originalFetch = window.fetch;
        window.fetch = function(url, options) {
          const urlStr = String(url || '');
          if (shouldSuppress(urlStr)) {
            // Return a rejected promise that won't trigger errors
            return Promise.reject(new Error('Blocked by nuclear-level suppression'));
          }
          return originalFetch.apply(this, arguments);
        };
        
        // NUCLEAR: Block all XMLHttpRequest to extension URLs
        const OriginalXMLHttpRequest = window.XMLHttpRequest;
        window.XMLHttpRequest = function() {
          const xhr = new OriginalXMLHttpRequest();
          const originalOpen = xhr.open;
          xhr.open = function(method, url, async, user, password) {
            const urlStr = String(url || '');
            if (shouldSuppress(urlStr)) {
              // Make it fail silently
              xhr.readyState = 4;
              xhr.status = 0;
              xhr.statusText = 'Blocked';
              return;
            }
            return originalOpen.apply(this, arguments);
          };
          return xhr;
        };
        
        // IMMEDIATE: Log that nuclear-level suppression is active
        originalConsole.log('☢️ NUCLEAR-LEVEL ERROR SUPPRESSION ACTIVATED - ALL EXTENSION ERRORS COMPLETELY BLOCKED');
        
      })();
    </script>
    
    <script type="module" crossorigin src="/src/main.tsx"></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>