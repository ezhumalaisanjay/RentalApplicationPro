<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com data:; img-src 'self' data: https:; connect-src 'self' https://hook.us1.make.com; worker-src 'none'; child-src 'none'; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self';">
    
    <!-- CSS-BASED EXTENSION BLOCKING -->
    <style>
      /* Hide all extension-related elements */
      [src*="chrome-extension"],
      [src*="moz-extension"],
      [src*="safari-extension"],
      [src*="ms-browser-extension"],
      [src*="extension://"],
      [src*="localhost:8098"],
      [src*="ws://localhost:8098"],
      [src*="inject.bundle.js"],
      [src*="multi-tabs.js"],
      [src*="hook.js"],
      [src*="extension"],
      [src*="addon"],
      [src*="plugin"],
      [src*="devtools"],
      [src*="inspector"],
      [src*="debugger"],
      [src*="source map"],
      [src*="eval"],
      [src*="inline script"],
      [src*="content script"],
      [src*="background script"],
      [src*="service worker"],
      [src*="manifest"],
      [src*="permissions"],
      [src*="storage"],
      [src*="tabs"],
      [src*="bookmarks"],
      [src*="history"],
      [src*="cookies"],
      [src*="webrequest"],
      [src*="webnavigation"],
      [src*="notifications"],
      [src*="alarms"],
      [src*="idle"],
      [src*="power"],
      [src*="system"],
      [src*="management"],
      [src*="enterprise"],
      [src*="identity"],
      [src*="oauth2"],
      [src*="chrome.runtime"],
      [src*="chrome.tabs"],
      [src*="chrome.bookmarks"],
      [src*="chrome.history"],
      [src*="chrome.cookies"],
      [src*="chrome.webrequest"],
      [src*="chrome.webnavigation"],
      [src*="chrome.notifications"],
      [src*="chrome.alarms"],
      [src*="chrome.idle"],
      [src*="chrome.power"],
      [src*="chrome.system"],
      [src*="chrome.management"],
      [src*="chrome.enterprise"],
      [src*="chrome.identity"],
      [src*="chrome.oauth2"],
      [src*="browser.runtime"],
      [src*="browser.tabs"],
      [src*="browser.bookmarks"],
      [src*="browser.history"],
      [src*="browser.cookies"],
      [src*="browser.webrequest"],
      [src*="browser.webnavigation"],
      [src*="browser.notifications"],
      [src*="browser.alarms"],
      [src*="browser.idle"],
      [src*="browser.power"],
      [src*="browser.system"],
      [src*="browser.management"],
      [src*="browser.enterprise"],
      [src*="browser.identity"],
      [src*="browser.oauth2"] {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
        position: absolute !important;
        left: -9999px !important;
        top: -9999px !important;
        width: 0 !important;
        height: 0 !important;
        overflow: hidden !important;
        clip: rect(0, 0, 0, 0) !important;
        margin: 0 !important;
        padding: 0 !important;
        border: 0 !important;
        outline: 0 !important;
        background: transparent !important;
        color: transparent !important;
        font-size: 0 !important;
        line-height: 0 !important;
        z-index: -9999 !important;
      }
      
      /* Hide any elements with extension-related classes or IDs */
      [class*="extension"],
      [class*="addon"],
      [class*="plugin"],
      [class*="devtools"],
      [class*="inspector"],
      [class*="debugger"],
      [class*="chrome"],
      [class*="browser"],
      [class*="multi-tabs"],
      [class*="hook"],
      [class*="inject"],
      [id*="extension"],
      [id*="addon"],
      [id*="plugin"],
      [id*="devtools"],
      [id*="inspector"],
      [id*="debugger"],
      [id*="chrome"],
      [id*="browser"],
      [id*="multi-tabs"],
      [id*="hook"],
      [id*="inject"] {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
        position: absolute !important;
        left: -9999px !important;
        top: -9999px !important;
        width: 0 !important;
        height: 0 !important;
        overflow: hidden !important;
        clip: rect(0, 0, 0, 0) !important;
        margin: 0 !important;
        padding: 0 !important;
        border: 0 !important;
        outline: 0 !important;
        background: transparent !important;
        color: transparent !important;
        font-size: 0 !important;
        line-height: 0 !important;
        z-index: -9999 !important;
      }
    </style>
    
    <!-- ULTRA-EARLY ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // Store original console methods immediately
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Early message filter
        function shouldSuppressEarly(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket connection to ws://localhost:8098/',
            'websocket connection to ws://localhost:8098',
            'websocket not connected',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'websocket',
            'ws://localhost',
            'websocket connection failed',
            'websocket error',
            'multi-tabs',
            'injected css'
          ];
          
          return blockedPatterns.some(pattern => msg.includes(pattern));
        }
        
        // Override console methods immediately
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppressEarly(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        // Block WebSocket immediately
        const OriginalWebSocket = window.WebSocket;
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
            const dummySocket = {
              readyState: 3,
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            return dummySocket;
          }
          return new OriginalWebSocket(url, protocols);
        };
        
        originalConsole.log('🚀 ULTRA-EARLY ERROR SUPPRESSION ACTIVATED');
        
      })();
    </script>
    
    <!-- NUCLEAR-LEVEL ERROR SUPPRESSION - RUNS BEFORE ANYTHING ELSE -->
    <script>
      (function() {
        'use strict';
        
        // NUCLEAR: Block WebSocket IMMEDIATELY before anything else
        const OriginalWebSocket = window.WebSocket;
        window.WebSocket = function(url, protocols) {
          const urlStr = String(url || '');
          if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
            // Return a completely inert WebSocket that does absolutely nothing
            const dummySocket = {
              readyState: 3, // CLOSED
              url: urlStr,
              protocol: protocols || '',
              extensions: '',
              bufferedAmount: 0,
              onopen: null,
              onclose: null,
              onmessage: null,
              onerror: null,
              send: function() { /* DO NOTHING */ },
              close: function() { /* DO NOTHING */ },
              addEventListener: function() { /* DO NOTHING */ },
              removeEventListener: function() { /* DO NOTHING */ },
              dispatchEvent: function() { return false; }
            };
            
            // Prevent any error events
            setTimeout(() => {
              if (dummySocket.onerror) {
                try {
                  dummySocket.onerror(new Event('error'));
                } catch (e) {
                  // Ignore everything
                }
              }
            }, 0);
            
            return dummySocket;
          }
          return new OriginalWebSocket(url, protocols);
        };
        
        // NUCLEAR: Override console methods IMMEDIATELY
        const originalConsole = {
          error: console.error,
          warn: console.warn,
          log: console.log
        };
        
        // Nuclear-level message filter - ENHANCED
        function shouldSuppress(message) {
          const msg = String(message).toLowerCase();
          const blockedPatterns = [
            'message port closed',
            'websocket connection to ws://localhost:8098/',
            'websocket connection to ws://localhost:8098',
            'websocket not connected',
            'inject.bundle.js',
            'runtime.lasterror',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'injected css loaded successfully',
            'unchecked runtime.lasterror',
            'multi-tabs.js',
            'hook.js',
            'websocket',
            'ws://localhost',
            'websocket connection failed',
            'websocket error',
            'multi-tabs',
            'injected css',
            'applicationinstructions component loaded',
            'component loaded',
            'extension error',
            'extension warning',
            'extension log',
            'browser extension',
            'addon',
            'plugin',
            'devtools',
            'inspector',
            'debugger',
            'source map',
            'eval',
            'inline script',
            'content script',
            'background script',
            'service worker',
            'manifest',
            'permissions',
            'storage',
            'tabs',
            'bookmarks',
            'history',
            'cookies',
            'webrequest',
            'webnavigation',
            'notifications',
            'alarms',
            'idle',
            'power',
            'system',
            'management',
            'enterprise',
            'identity',
            'oauth2',
            'chrome.runtime',
            'chrome.tabs',
            'chrome.bookmarks',
            'chrome.history',
            'chrome.cookies',
            'chrome.webrequest',
            'chrome.webnavigation',
            'chrome.notifications',
            'chrome.alarms',
            'chrome.idle',
            'chrome.power',
            'chrome.system',
            'chrome.management',
            'chrome.enterprise',
            'chrome.identity',
            'chrome.oauth2',
            'browser.runtime',
            'browser.tabs',
            'browser.bookmarks',
            'browser.history',
            'browser.cookies',
            'browser.webrequest',
            'browser.webnavigation',
            'browser.notifications',
            'browser.alarms',
            'browser.idle',
            'browser.power',
            'browser.system',
            'browser.management',
            'browser.enterprise',
            'browser.identity',
            'browser.oauth2',
            // Specific patterns from the current errors
            'understand this error',
            'inject.bundle.js:71',
            'inject.bundle.js:216',
            'multi-tabs.js:3565',
            'jotform-v.netlify.app',
            'anonymous',
            'e @',
            '@ inject.bundle.js',
            '@ multi-tabs.js',
            'chrome-extension://',
            'moz-extension://',
            'safari-extension://',
            'ms-browser-extension://',
            'extension://',
            'localhost:8098',
            'ws://localhost:8098',
            'websocket connection to',
            'websocket connection failed',
            'websocket error',
            'message port closed',
            'runtime.lasterror',
            'unchecked runtime.lasterror',
            'injected css loaded successfully',
            'multi-tabs',
            'hook.js',
            'inject.bundle',
            'multi-tabs.js',
            'hook.js',
            'injected css',
            'extension error',
            'extension warning',
            'extension log',
            'browser extension',
            'addon',
            'plugin',
            'devtools',
            'inspector',
            'debugger',
            'source map',
            'eval',
            'inline script',
            'content script',
            'background script',
            'service worker',
            'manifest',
            'permissions',
            'storage',
            'tabs',
            'bookmarks',
            'history',
            'cookies',
            'webrequest',
            'webnavigation',
            'notifications',
            'alarms',
            'idle',
            'power',
            'system',
            'management',
            'enterprise',
            'identity',
            'oauth2',
            'chrome.runtime',
            'chrome.tabs',
            'chrome.bookmarks',
            'chrome.history',
            'chrome.cookies',
            'chrome.webrequest',
            'chrome.webnavigation',
            'chrome.notifications',
            'chrome.alarms',
            'chrome.idle',
            'chrome.power',
            'chrome.system',
            'chrome.management',
            'chrome.enterprise',
            'chrome.identity',
            'chrome.oauth2',
            'browser.runtime',
            'browser.tabs',
            'browser.bookmarks',
            'browser.history',
            'browser.cookies',
            'browser.webrequest',
            'browser.webnavigation',
            'browser.notifications',
            'browser.alarms',
            'browser.idle',
            'browser.power',
            'browser.system',
            'browser.management',
            'browser.enterprise',
            'browser.identity',
            'browser.oauth2'
          ];
          
          // Only block if the message contains extension-related patterns
          // AND is not from our application
          const isExtensionRelated = blockedPatterns.some(pattern => msg.includes(pattern));
          const isOurApp = msg.includes('react') || 
                          msg.includes('vite') || 
                          msg.includes('main.tsx') || 
                          msg.includes('application') ||
                          msg.includes('rental') ||
                          msg.includes('liberty place') ||
                          msg.includes('jotform') ||
                          msg.includes('netlify') ||
                          msg.includes('localhost:5000') ||
                          msg.includes('localhost:3000') ||
                          msg.includes('localhost:5173');
          
          return isExtensionRelated && !isOurApp;
        }
        
        // Override console.error with nuclear-level filtering
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.error.apply(console, args);
        };
        
        // Override console.warn with nuclear-level filtering
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          originalConsole.warn.apply(console, args);
        };
        
        // Override console.log to filter extension messages
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Suppress extension-related logs
          }
          originalConsole.log.apply(console, args);
        };
        
        // NUCLEAR: Block all error events globally
        window.addEventListener('error', function(event) {
          const message = String(event.message || '');
          const filename = String(event.filename || '');
          if (shouldSuppress(message) || shouldSuppress(filename)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
          const message = String(event.reason?.message || event.reason || '');
          if (shouldSuppress(message)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block security policy violations
        window.addEventListener('securitypolicyviolation', function(event) {
          if (shouldSuppress(event.violatedDirective) || shouldSuppress(event.blockedURI)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block beforeunload events from extensions
        window.addEventListener('beforeunload', function(event) {
          if (shouldSuppress(event.type)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return false;
          }
        }, true);
        
        // NUCLEAR: Block all fetch requests to extension URLs
        const originalFetch = window.fetch;
        window.fetch = function(url, options) {
          const urlStr = String(url || '');
          if (shouldSuppress(urlStr)) {
            // Return a rejected promise that won't trigger errors
            return Promise.reject(new Error('Blocked by nuclear-level suppression'));
          }
          return originalFetch.apply(this, arguments);
        };
        
        // NUCLEAR: Block all XMLHttpRequest to extension URLs
        const OriginalXMLHttpRequest = window.XMLHttpRequest;
        window.XMLHttpRequest = function() {
          const xhr = new OriginalXMLHttpRequest();
          const originalOpen = xhr.open;
          xhr.open = function(method, url, async, user, password) {
            const urlStr = String(url || '');
            if (shouldSuppress(urlStr)) {
              // Make it fail silently
              xhr.readyState = 4;
              xhr.status = 0;
              xhr.statusText = 'Blocked';
              return;
            }
            return originalOpen.apply(this, arguments);
          };
          return xhr;
        };
        
        // IMMEDIATE: Log that nuclear-level suppression is active
        originalConsole.log('☢️ NUCLEAR-LEVEL ERROR SUPPRESSION ACTIVATED - ALL EXTENSION ERRORS COMPLETELY BLOCKED');
        
        // NUCLEAR: Continuous monitoring system to catch late-arriving errors
        setInterval(() => {
          // Re-apply console overrides in case they were overridden
          console.error = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsole.error.apply(console, args);
          };
          
          console.warn = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            originalConsole.warn.apply(console, args);
          };
          
          console.log = function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Suppress extension-related logs
            }
            originalConsole.log.apply(console, args);
          };
          
          // Re-apply WebSocket blocking
          if (window.WebSocket !== OriginalWebSocket) {
            window.WebSocket = function(url, protocols) {
              const urlStr = String(url || '');
              if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
                const dummySocket = {
                  readyState: 3,
                  url: urlStr,
                  protocol: protocols || '',
                  extensions: '',
                  bufferedAmount: 0,
                  onopen: null,
                  onclose: null,
                  onmessage: null,
                  onerror: null,
                  send: function() { /* DO NOTHING */ },
                  close: function() { /* DO NOTHING */ },
                  addEventListener: function() { /* DO NOTHING */ },
                  removeEventListener: function() { /* DO NOTHING */ },
                  dispatchEvent: function() { return false; }
                };
                return dummySocket;
              }
              return new OriginalWebSocket(url, protocols);
            };
          }
        }, 100); // Check every 100ms
        
        // NUCLEAR: MutationObserver to catch dynamically injected scripts
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList') {
              mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                  const element = node;
                  // Block any script tags that might be extension-related
                  if (element.tagName === 'SCRIPT') {
                    const src = element.getAttribute('src') || '';
                    if (shouldSuppress(src)) {
                      element.remove();
                      return;
                    }
                  }
                  // Block any iframes that might be extension-related
                  if (element.tagName === 'IFRAME') {
                    const src = element.getAttribute('src') || '';
                    if (shouldSuppress(src)) {
                      element.remove();
                      return;
                    }
                  }
                }
              });
            }
          });
        });
        
        // Start observing
        observer.observe(document, {
          childList: true,
          subtree: true
        });
        
        // NUCLEAR: Block all global error handlers that extensions might add
        const originalAddEventListener = window.addEventListener;
        window.addEventListener = function(type, listener, options) {
          if (type === 'error' || type === 'unhandledrejection') {
            // Wrap the listener to filter out extension errors
            const wrappedListener = function(event) {
              const message = String(event.message || event.reason?.message || event.reason || '');
              if (shouldSuppress(message)) {
                return; // Block the event
              }
              return listener.call(this, event);
            };
            return originalAddEventListener.call(this, type, wrappedListener, options);
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
        
        // NUCLEAR: Block all error propagation at the DOM level
        const originalDispatchEvent = EventTarget.prototype.dispatchEvent;
        EventTarget.prototype.dispatchEvent = function(event) {
          if (event.type === 'error' || event.type === 'unhandledrejection') {
            const message = String(event.message || event.reason?.message || event.reason || '');
            if (shouldSuppress(message)) {
              event.preventDefault();
              event.stopImmediatePropagation();
              return false; // Block the event entirely
            }
          }
          return originalDispatchEvent.call(this, event);
        };
        
        // NUCLEAR: Block all console methods at the prototype level
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        const originalConsoleLog = console.log;
        
        Object.defineProperty(console, 'error', {
          value: function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            return originalConsoleError.apply(console, args);
          },
          writable: false,
          configurable: false
        });
        
        Object.defineProperty(console, 'warn', {
          value: function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Completely suppress
            }
            return originalConsoleWarn.apply(console, args);
          },
          writable: false,
          configurable: false
        });
        
        Object.defineProperty(console, 'log', {
          value: function(...args) {
            const message = args.join(' ');
            if (shouldSuppress(message)) {
              return; // Suppress extension-related logs
            }
            return originalConsoleLog.apply(console, args);
          },
          writable: false,
          configurable: false
        });
        
        // NUCLEAR: Block all error constructors
        const originalError = window.Error;
        window.Error = function(message, ...args) {
          if (shouldSuppress(String(message || ''))) {
            // Return a silent error that does nothing
            const silentError = new originalError('Blocked by nuclear suppression');
            silentError.stack = '';
            silentError.message = '';
            return silentError;
          }
          return new originalError(message, ...args);
        };
        
        // NUCLEAR: Block all Promise rejections at the constructor level
        const originalPromise = window.Promise;
        window.Promise = function(executor) {
          return new originalPromise(function(resolve, reject) {
            const wrappedReject = function(reason) {
              if (shouldSuppress(String(reason || ''))) {
                // Silently ignore the rejection
                return;
              }
              return reject(reason);
            };
            return executor(resolve, wrappedReject);
          });
        };
        
        // NUCLEAR: Block all setTimeout/setInterval that might be used by extensions
        const originalSetTimeout = window.setTimeout;
        const originalSetInterval = window.setInterval;
        
        window.setTimeout = function(func, delay, ...args) {
          if (typeof func === 'string' && shouldSuppress(func)) {
            return 0; // Return invalid timeout ID
          }
          if (typeof func === 'function') {
            const wrappedFunc = function(...funcArgs) {
              try {
                return func.apply(this, funcArgs);
              } catch (error) {
                if (shouldSuppress(String(error || ''))) {
                  return; // Silently ignore
                }
                throw error;
              }
            };
            return originalSetTimeout(wrappedFunc, delay, ...args);
          }
          return originalSetTimeout(func, delay, ...args);
        };
        
        window.setInterval = function(func, delay, ...args) {
          if (typeof func === 'string' && shouldSuppress(func)) {
            return 0; // Return invalid interval ID
          }
          if (typeof func === 'function') {
            const wrappedFunc = function(...funcArgs) {
              try {
                return func.apply(this, funcArgs);
              } catch (error) {
                if (shouldSuppress(String(error || ''))) {
                  return; // Silently ignore
                }
                throw error;
              }
            };
            return originalSetInterval(wrappedFunc, delay, ...args);
          }
          return originalSetInterval(func, delay, ...args);
        };
        
        // NUCLEAR: Block all eval and Function constructors
        const originalEval = window.eval;
        window.eval = function(code) {
          if (shouldSuppress(String(code || ''))) {
            return undefined; // Return undefined instead of executing
          }
          return originalEval(code);
        };
        
        const originalFunction = window.Function;
        window.Function = function(...args) {
          const code = args.join('');
          if (shouldSuppress(code)) {
            return function() { return undefined; }; // Return empty function
          }
          return originalFunction.apply(this, args);
        };
        
        // NUCLEAR: Block all error stack traces
        const originalErrorStack = Error.prototype.stack;
        Object.defineProperty(Error.prototype, 'stack', {
          get: function() {
            const stack = originalErrorStack;
            if (shouldSuppress(stack)) {
              return ''; // Return empty stack trace
            }
            return stack;
          },
          set: function(value) {
            if (shouldSuppress(String(value || ''))) {
              return; // Don't set the stack trace
            }
            originalErrorStack = value;
          }
        });
        
        // NUCLEAR: Block all console methods at the deepest level possible
        const consoleProxy = new Proxy(console, {
          get: function(target, prop) {
            if (prop === 'error' || prop === 'warn' || prop === 'log') {
              return function(...args) {
                const message = args.join(' ');
                if (shouldSuppress(message)) {
                  return; // Completely suppress
                }
                return target[prop].apply(target, args);
              };
            }
            return target[prop];
          }
        });
        
        // Replace the global console with our proxy
        Object.defineProperty(window, 'console', {
          value: consoleProxy,
          writable: false,
          configurable: false
        });
        
        // NUCLEAR: Block all error events at the window level
        const originalWindowError = window.onerror;
        window.onerror = function(message, source, lineno, colno, error) {
          if (shouldSuppress(String(message || '')) || shouldSuppress(String(source || ''))) {
            return true; // Prevent the error from being logged
          }
          if (originalWindowError) {
            return originalWindowError.call(this, message, source, lineno, colno, error);
          }
          return false;
        };
        
        // NUCLEAR: Block all unhandledrejection events at the window level
        const originalWindowUnhandledRejection = window.onunhandledrejection;
        window.onunhandledrejection = function(event) {
          if (shouldSuppress(String(event.reason || ''))) {
            event.preventDefault();
            return true; // Prevent the rejection from being logged
          }
          if (originalWindowUnhandledRejection) {
            return originalWindowUnhandledRejection.call(this, event);
          }
          return false;
        };
        
        // NUCLEAR: Block all script loading at the document level
        const originalCreateElement = document.createElement;
        document.createElement = function(tagName) {
          const element = originalCreateElement.call(document, tagName);
          if (tagName.toLowerCase() === 'script') {
            const originalSetAttribute = element.setAttribute;
            element.setAttribute = function(name, value) {
              if (name === 'src' && shouldSuppress(String(value || ''))) {
                // Don't set the src attribute for blocked scripts
                return;
              }
              return originalSetAttribute.call(this, name, value);
            };
            
            const originalAppendChild = element.appendChild;
            element.appendChild = function(child) {
              if (shouldSuppress(String(child || ''))) {
                return child; // Return the child without appending
              }
              return originalAppendChild.call(this, child);
            };
          }
          return element;
        };
        
        // NUCLEAR: Block all script execution
        const originalAppendChild = Node.prototype.appendChild;
        const originalInsertBefore = Node.prototype.insertBefore;
        const originalReplaceChild = Node.prototype.replaceChild;
        
        Node.prototype.appendChild = function(child) {
          if (child && child.tagName === 'SCRIPT') {
            const src = child.getAttribute('src') || '';
            const text = child.textContent || '';
            if (shouldSuppress(src) || shouldSuppress(text)) {
              // Create a dummy script that does nothing
              const dummyScript = document.createElement('script');
              dummyScript.textContent = '// Blocked by nuclear suppression';
              return originalAppendChild.call(this, dummyScript);
            }
          }
          return originalAppendChild.call(this, child);
        };
        
        Node.prototype.insertBefore = function(child, referenceNode) {
          if (child && child.tagName === 'SCRIPT') {
            const src = child.getAttribute('src') || '';
            const text = child.textContent || '';
            if (shouldSuppress(src) || shouldSuppress(text)) {
              // Create a dummy script that does nothing
              const dummyScript = document.createElement('script');
              dummyScript.textContent = '// Blocked by nuclear suppression';
              return originalInsertBefore.call(this, dummyScript, referenceNode);
            }
          }
          return originalInsertBefore.call(this, child, referenceNode);
        };
        
        Node.prototype.replaceChild = function(newChild, oldChild) {
          if (newChild && newChild.tagName === 'SCRIPT') {
            const src = newChild.getAttribute('src') || '';
            const text = newChild.textContent || '';
            if (shouldSuppress(src) || shouldSuppress(text)) {
              // Create a dummy script that does nothing
              const dummyScript = document.createElement('script');
              dummyScript.textContent = '// Blocked by nuclear suppression';
              return originalReplaceChild.call(this, dummyScript, oldChild);
            }
          }
          return originalReplaceChild.call(this, newChild, oldChild);
        };
        
        // NUCLEAR: Block all dynamic script creation
        const originalCreateElementNS = document.createElementNS;
        document.createElementNS = function(namespaceURI, qualifiedName) {
          const element = originalCreateElementNS.call(document, namespaceURI, qualifiedName);
          if (qualifiedName.toLowerCase() === 'script') {
            const originalSetAttribute = element.setAttribute;
            element.setAttribute = function(name, value) {
              if (name === 'src' && shouldSuppress(String(value || ''))) {
                return; // Don't set the src attribute
              }
              return originalSetAttribute.call(this, name, value);
            };
          }
          return element;
        };
        
        // NUCLEAR: Block all iframe creation
        const originalCreateElementIframe = document.createElement;
        document.createElement = function(tagName) {
          const element = originalCreateElementIframe.call(document, tagName);
          if (tagName.toLowerCase() === 'iframe') {
            const originalSetAttribute = element.setAttribute;
            element.setAttribute = function(name, value) {
              if (name === 'src' && shouldSuppress(String(value || ''))) {
                return; // Don't set the src attribute
              }
              return originalSetAttribute.call(this, name, value);
            };
          }
          return element;
        };
        
        // NUCLEAR: Block all browser extension APIs
        if (typeof chrome !== 'undefined') {
          Object.defineProperty(window, 'chrome', {
            get: function() {
              return undefined; // Return undefined instead of chrome object
            },
            set: function() {
              return; // Prevent setting
            },
            configurable: false
          });
        }
        
        if (typeof browser !== 'undefined') {
          Object.defineProperty(window, 'browser', {
            get: function() {
              return undefined; // Return undefined instead of browser object
            },
            set: function() {
              return; // Prevent setting
            },
            configurable: false
          });
        }
        
        // NUCLEAR: Block all extension-related global variables
        const extensionGlobals = [
          'chrome',
          'browser',
          'extension',
          'addon',
          'plugin',
          'devtools',
          'inspector',
          'debugger',
          'multi-tabs',
          'hook',
          'inject'
        ];
        
        extensionGlobals.forEach(function(globalName) {
          if (window[globalName]) {
            Object.defineProperty(window, globalName, {
              get: function() {
                return undefined;
              },
              set: function() {
                return;
              },
              configurable: false
            });
          }
        });
        
        // NUCLEAR: Block all extension-related function calls
        const originalCall = Function.prototype.call;
        const originalApply = Function.prototype.apply;
        
        Function.prototype.call = function(thisArg, ...args) {
          const funcStr = this.toString();
          if (shouldSuppress(funcStr)) {
            return undefined; // Return undefined instead of calling
          }
          return originalCall.call(this, thisArg, ...args);
        };
        
        Function.prototype.apply = function(thisArg, argsArray) {
          const funcStr = this.toString();
          if (shouldSuppress(funcStr)) {
            return undefined; // Return undefined instead of calling
          }
          return originalApply.call(this, thisArg, argsArray);
        };
        
        // NUCLEAR: Block all extension-related property access
        const originalGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        Object.getOwnPropertyDescriptor = function(obj, prop) {
          const descriptor = originalGetOwnPropertyDescriptor.call(Object, obj, prop);
          if (descriptor && shouldSuppress(String(prop))) {
            return undefined; // Return undefined descriptor
          }
          return descriptor;
        };
        
        // NUCLEAR: Block all extension-related property definition
        const originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function(obj, prop, descriptor) {
          if (shouldSuppress(String(prop))) {
            return obj; // Return the object without defining the property
          }
          return originalDefineProperty.call(Object, obj, prop, descriptor);
        };
        
        // NUCLEAR: Block all extension-related property deletion
        const originalDeleteProperty = Object.deleteProperty;
        Object.deleteProperty = function(obj, prop) {
          if (shouldSuppress(String(prop))) {
            return true; // Pretend the deletion was successful
          }
          return originalDeleteProperty.call(Object, obj, prop);
        };
        
        // NUCLEAR: Block all extension-related property enumeration
        const originalGetOwnPropertyNames = Object.getOwnPropertyNames;
        Object.getOwnPropertyNames = function(obj) {
          const names = originalGetOwnPropertyNames.call(Object, obj);
          return names.filter(function(name) {
            return !shouldSuppress(String(name));
          });
        };
        
        // NUCLEAR: Block all extension-related property keys
        const originalKeys = Object.keys;
        Object.keys = function(obj) {
          const keys = originalKeys.call(Object, obj);
          return keys.filter(function(key) {
            return !shouldSuppress(String(key));
          });
        };
        
        // NUCLEAR: Block all error reporting at the browser level
        const originalErrorReporter = window.reportError || window.onerror;
        window.reportError = function(error) {
          if (shouldSuppress(String(error || ''))) {
            return; // Don't report the error
          }
          if (originalErrorReporter) {
            return originalErrorReporter.call(this, error);
          }
        };
        
        // NUCLEAR: Block only extension-related console messages
        const originalConsoleErrorNative = console.error;
        const originalConsoleWarnNative = console.warn;
        const originalConsoleLogNative = console.log;
        
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          return originalConsoleErrorNative.apply(console, args);
        };
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Completely suppress
          }
          return originalConsoleWarnNative.apply(console, args);
        };
        
        console.log = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Suppress extension-related logs
          }
          return originalConsoleLogNative.apply(console, args);
        };
        

        
        // NUCLEAR: Block all WebSocket connections at the native level
        const originalWebSocketConstructor = window.WebSocket;
        Object.defineProperty(window, 'WebSocket', {
          value: function(url, protocols) {
            const urlStr = String(url || '');
            if (urlStr.includes('localhost:8098') || urlStr.includes('ws://localhost:8098')) {
              // Return a completely inert WebSocket that does absolutely nothing
              const dummySocket = {
                readyState: 3, // CLOSED
                url: urlStr,
                protocol: protocols || '',
                extensions: '',
                bufferedAmount: 0,
                onopen: null,
                onclose: null,
                onmessage: null,
                onerror: null,
                send: function() { /* DO NOTHING */ },
                close: function() { /* DO NOTHING */ },
                addEventListener: function() { /* DO NOTHING */ },
                removeEventListener: function() { /* DO NOTHING */ },
                dispatchEvent: function() { return false; }
              };
              
              // Prevent any error events from firing
              setTimeout(() => {
                if (dummySocket.onerror) {
                  try {
                    dummySocket.onerror(new Event('error'));
                  } catch (e) {
                    // Ignore everything
                  }
                }
              }, 0);
              
              return dummySocket;
            }
            return new originalWebSocketConstructor(url, protocols);
          },
          writable: false,
          configurable: false
        });
        
        // NUCLEAR: Block only extension-related network requests
        const originalFetchNative = window.fetch;
        window.fetch = function(url, options) {
          const urlStr = String(url || '');
          if (shouldSuppress(urlStr)) {
            // Return a rejected promise that won't trigger errors
            return Promise.reject(new Error('Blocked by nuclear suppression'));
          }
          return originalFetchNative.call(this, url, options);
        };
        
      })();
    </script>
    
    <script type="module" crossorigin src="/src/main.tsx"></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>